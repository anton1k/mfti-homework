'''Дан ориентированный граф. Вершины пронумерованы от 0. Требуется с помощью топологической сортировки линейно упорядочить вершины графа в список так, чтобы для любого ребра графа из вершины A в вершину B, вершина A была левее чем B в списке.

Формат входных данных
На вход программе в первой строке подаются через пробел два числа: N (2 <= N <= 1000) - число вершин в графе и M (1 <= M <= 20000) - число ребер. В следующих M строках задаются ребра, по два числа в каждой строке - номера соединенных вершин (соответствующее ребро идет из первой вершины во вторую).

Формат выходных данных
Требуется распечатать топологически отсортированный список вершин, если такой существует. Если упорядочить вершины можно несколькими способами выведите любой из них. Если упорядочить вершины нельзя выведите "NO" без кавычек.'''

n, m = map(int, input().split())  # количество вершин и ребер в графе
adj = [[] for i in range(n)]  # список смежности
color = [int(0) for i in range(n)]  # массив для хранения цветов вершин
topSort = []  # топологически упорядоченная перестановка вершин графа

# считываем граф, заданный списком ребер
for i in range(m):
    v, w = map(int, input().split())
    v -= 1
    w -= 1
    adj[v].append(w)


def topologicalSort(v):  # топологическая сортировка вершин графа

    # если вершина является черной, то не производим из нее вызов процедуры
    if color[v] == 2:
        return True
    # если вершина является серой, то орграф содержит цикл, выходим из процедуры
    if color[v] == 1:
        return False
    color[v] = 1  # помечаем вершину как серую
    # запускаем обход из всех вершин, смежных с вершиной v
    for w in adj[v]:
        # вызов обхода от вершины w, смежной с вершиной v
        if not topologicalSort(w):
            return False
    color[v] = 2  # помечаем вершину как черную
    # добавляем посещенную вершину в топологический порядок
    topSort.append(v)
    return True


def run():

    cyclic = False  # флаг, показывающий содержит орграф цикл или нет
    # запускаем процедуру, которая топологически сортирует вершины графа
    for v in range(n):
        if not topologicalSort(v):
            cyclic = True
        if not cyclic:
            topSort.reverse()
    # иначе выводим топологически упорядоченную перестановку его вершин
    if len(topSort) > 1:
        print(' '.join(str(x+1) for x in topSort))
    else:
        print('NO')
run()