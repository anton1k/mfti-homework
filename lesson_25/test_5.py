'''Дан ориентированный граф. Вершины пронумерованы от 0. Трeбуется с помощью обхода в глубину проверить является ли граф ацикличным.

Формат входных данных
На вход программе в первой строке подаются через пробел два числа: N (2 <= N <= 1000) - число вершин в графе и M (1 <= M <= 20000) - число ребер. В следующих M строках задаются ребра, по два числа в каждой строке - номера соединенных вершин (соответствующее ребро идет из первой вершины во вторую).

Формат выходных данных
Требуется распечатать номера вершин, задающих цикл в графе если он существует. Номера вершин нужно вывести в порядке следования по циклу. Если циклов несколько вывести любой. Если граф ацикличный вывести строку "YES" без кавычек.'''

n, m = '8', '8'
v = [['7', '3'], ['3', '1'], ['5', '2'], ['6', '4'], ['6', '7'],[ '4', '7'], ['1', '6'], ['1', '2']]

# n, m = '4', '1'
# v = [['3', '1']]
# a, b = v[i][0], v[i][1]

n, m = input().split()
graph = {}

color = ['white']*int(n)

for i in range(int(m)):
    a, b = input().split() 
    # a, b = v[i][0], v[i][1]
    if str(i) not in graph:
        graph[str(i)] = set()
    if a not in graph:
        graph[a] = set()
    graph[a].add(b)

def dfs(v, path=None): 
    if path is None:
        path = []
    color[v] = 'grey'    
    if str(v) in graph:
        for u in graph[str(v)]:
            if color[int(u)] == 'white':
                dfs(int(u), path)
            if color[int(u)] == 'grey':
                path.append(v)
                return path 

    color[v] = 'black'

for i in range(0, int(n)):
    tmp = dfs(i)
    if (tmp is not None) and (len(tmp) > 1):
        print(' '.join(str(x) for x in tmp[::-1]))
        break
else:
    print('YES')

